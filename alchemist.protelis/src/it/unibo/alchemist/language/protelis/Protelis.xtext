grammar it.unibo.alchemist.language.protelis.Protelis with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate protelis "http://alchemist.apice.unibo.it/Protelis"

Program: package=PackageDeclaration? (imports+=Import)* (definitions+=FunctionDef)* program=Block;

VarList: args += VAR (',' args += VAR)* ;

RepList: args+=RepInitialize (',' args+=RepInitialize)*;
ExprList: args+=Expression (',' args+=Expression)*;
RepInitialize: x=VAR '<-' w=VarVal;

PackageDeclaration:
	'package' name=QualifiedName
;

Import:
	'import' class=QualifiedName'.' method=ID 'as' name=ID |
	'import' class=QualifiedName'.' name=(ID|'*')
;

Block: (first=Statement) (';' others=Block)? ;

Statement: Assignment | LinkableStatement ;

Declaration:
	'let' name=QualifiedName '=' right=Expression
;

LinkableStatement: Declaration | Expression;

Assignment:
	refVar=[LinkableStatement|QualifiedName] name='=' right = Expression
;

Expression:
 	LogicalOr ';'?
;

FunctionDef: 'def' name=ID '(' (args=VarList)? ')' '{' body=Block '}';

FunctionCall returns Expression:
	(function=[FunctionDef|ID] | name='#' method=ID )'('args=ExprList?')'
;

Lambda returns Expression: '(' (lambdaArgs=VarList)? ')' name='->' '{' body=Block '}';

Rep returns Expression: 
	name='rep' '(' init=RepList ')' '{' body=Block '}' 
;

If returns Expression:
	name='if' '(' cond=Expression ')' '{' then=Block '}' 'else' '{' else=Block '}'
;

NBR returns Expression:
	name='nbr' '(' arg=Expression ')' 
;

Builtin returns Expression:
	name='self' |
	name='nbrRange' |
	name='dt' |
	name='pi' |
	name='e' |
	name='random' |
	name='eval' '(' arg = ( VAR | StringVal ) ')' |
	name='alignedMap' '(' arg=Expression ',' cond=Expression ',' op=Expression ',' default=Expression ')' |
	name='mux' '(' cond=Expression ')' '{' then=Block '}' 'else' '{'  else=Block '}' |
	HoodOp
;

HoodOp returns Expression: (
	name='minHood' |
	name='maxHood' |
	name='anyHood' |
	name='allHood' |
	name='sumHood' |
	name='meanHood' |
	name='unionHood'
) inclusive='PlusSelf'? '(' arg=Expression ')'
;

LogicalOr returns Expression:
 LogicalAnd ({Expression.left=current} name='||' right=LogicalAnd)*;

LogicalAnd returns Expression:
 Equality ({Expression.left=current} name='&&' right=Equality)*;

Equality returns Expression:
 Relational ({Expression.left=current} name=('=='|'!=') right=Relational)*;

Relational returns Expression:
 Addition ({Expression.left=current} name=('>'|'>='|'<'|'<=') right=Addition)*;

Addition returns Expression:
 Multiplication ({Expression.left=current} name=('+'|'-') right=Multiplication)*;

Multiplication returns Expression:
 Power ({Expression.left=current} name=('*'|'/'|'%') right=Power)*;

Power returns Expression:
 Prefix ({Expression.left=current} name=('^') right=Prefix)*;

Prefix returns Expression:
    Postfix | ({Prefix} name=('-'|'!') right=Postfix);

Postfix returns Expression:
    Primary
    ({Expression.left=current}(
    	(name='.' methodName=('apply' | ID) '(' (args=ExprList)? ')')
    ))?
;

Primary returns Expression:
 (v = (VarVal | FunctionCall | Rep | NBR | If) | '(' Expression ')')
;

VarVal returns Expression: VAR | Local;

Local returns Expression : Scalar | Builtin | Lambda;

VAR: name=QualifiedName;

Scalar: DoubleVal | StringVal | BooleanVal | TupleVal;

DoubleVal: val=DOUBLE;

StringVal: val=STRING;

BooleanVal: val=BOOLEAN;

TupleVal: name='[' args = ExprList? ']';

QualifiedName: ID ('.' ID)* ;
QualifiedNameWithWildcard: QualifiedName '.*'? ;

DOUBLE returns ecore::EDouble: INT('.'INT)?('e'|'E''-'?INT)? | 'Infinity' | 'NaN';
BOOLEAN returns ecore::EBoolean: "true" | "false";

terminal ML_COMMENT	: '/*' -> '*/';
