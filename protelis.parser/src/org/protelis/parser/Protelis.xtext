grammar org.protelis.parser.Protelis with org.eclipse.xtext.xbase.Xtype
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

generate protelis "http://protelis.org"

ProtelisModule: ('module' name=ProtelisQualifiedName)?
	(imports=ImportSection)?
	(definitions+=FunctionDef)* program=Block?
;

ImportSection:
	importDeclarations+=ImportDeclaration+;

ImportDeclaration: 
	 =>(ProtelisImport) | JavaImport
;

JavaImport:
	name='import' (importedType=[jvmTypes::JvmDeclaredType|QualifiedNameInStaticImport] (wildcard?='*' | importedMemberName=AID))
;

ProtelisImport:
	name='import' module=[ProtelisModule|ProtelisQualifiedName]
;

ProtelisQualifiedName: ID (':' ID)* ;

FunctionDef: public?="public"? 'def' name=ID '(' (args=VarDefList)? ')' '{' body=Block '}';

VarDefList: args += VarDef (',' args += VarDef)* ;

VarDef: name = ID;

Block:
	(statements+=Statement ';'*)+
;

Statement: (=>Expression | SideEffect);

SideEffect: Declaration | Assignment | IfWithoutElse;

Declaration returns VarDef:
	'let' VarDef '=' right=Expression
;

Assignment:
	refVar=[VarDef] name='=' right = Expression
;

IfWithoutElse:
	name='if' '(' cond=Expression ')' '{' (then+=Statement (';' then+=Statement)*)? '}'
;

Expression:
 	LogicalOr
;

LogicalOr returns Expression:
 LogicalAnd ({Expression.left=current} name='||' right=LogicalAnd)*;

LogicalAnd returns Expression:
 Equality ({Expression.left=current} name='&&' right=Equality)*;

Equality returns Expression:
 Relational ({Expression.left=current} name=('=='|'!=') right=Relational)*;

Relational returns Expression:
 Addition ({Expression.left=current} name=('>'|'>='|'<'|'<=') right=Addition)*;

Addition returns Expression:
 Multiplication ({Expression.left=current} name=('+'|'-') right=Multiplication)*;

Multiplication returns Expression:
 Power ({Expression.left=current} name=('*'|'/'|'%') right=Power)*;

Power returns Expression:
 Prefix ({Expression.left=current} name=('^') right=Prefix)*;

Prefix returns Expression:
    Postfix | ({Prefix} name=('!') right=Postfix);

Postfix returns Expression:
    Primary
    ({Expression.left=current}(name='.' methodName=AID arguments=InvocationArguments))*
;

Primary returns Expression:
	=>Call
	| =>Builtin
	| =>AnyLambda
	| =>Rep
	| =>Share
	| =>NBR
	| =>If
	| VarUse
	| Scalar
	| '(' Expression ')'
;

Call:
	/*
	 * Use manual scoping to solve this
	 */
	reference=[ecore::EObject|CallRule] arguments=InvocationArguments
;
CallRule: AID (JCallElement+ | ProtelisCallElement+)?;
CallRuleNoConflict: AID (JCallElement+ | ProtelisCallElement+) | ID;
JCallElement: '::' AID;
ProtelisCallElement: ':' ID;

InvocationArguments:
	=> name='(' args=ExpressionList? ')' lastArg = Lambda
	| => name='(' args=ExpressionList? ')'
	| lastArg = Lambda
;

ExpressionList: args+=Expression (',' args+=Expression)*;

AnyLambda: Lambda | OldLambda;
Lambda:
  (
  	=> '{' args=VarDefList name='->'
  	| name='{'
  )
  body=Block '}'
;
OldLambda:
	'(' (args=VarDefList)? ')' name='->' '{' body=Block '}'
;

Rep: 
	name='rep' '(' init=RepInitialize ')' '{' body=Block '}' (yields = Yield)?
;
RepInitialize: x=VarDef '<-' w=Expression;
Share: 
	name='share' '(' init=ShareInitialize ')' '{' body=Block '}' (yields = Yield)?
;
ShareInitialize: (local=VarDef ',')? field=VarDef '<-' w=Expression;
Yield: name='yield' '{' body = Block '}';

NBR:
	name='nbr' '(' arg=Expression ')' 
;

If:
	name='if' '(' cond=Expression ')' '{' then=Block '}' 'else' '{' else=Block '}'
;

VarUse: reference=[ecore::EObject|CallRuleNoConflict];

Scalar: DoubleVal | StringVal | BooleanVal | TupleVal;

Builtin:
	Self | Env | It | Eval | AlignedMap | Mux | Hood
;
Self: name = 'self';
Env: name = 'env';
It: name = 'it';
Eval: name='eval' '(' arg = Expression ')';
AlignedMap: name='alignedMap' '(' arg=Expression ',' cond=Expression ',' op=Expression ',' default=Expression ')';
Mux: name='mux' '(' cond=Expression ')' '{' then=Block '}' 'else' '{'  else=Block '}';

Hood:
	BuiltinHoodOp |	GenericHood  
;
GenericHood:
	(name = 'hood' | name = 'hoodPlusSelf') '('
		(reference = VarUse | op = Lambda ) ','
		default = Expression ','
		arg = Expression
	')'
;
BuiltinHoodOp:
	(
	name='minHood' |
	name='maxHood' |
	name='localHood' |
	name='anyHood' |
	name='allHood' |
	name='sumHood' |
	name='meanHood' |
	name='unionHood'
) inclusive?='PlusSelf'? '(' arg=Expression ')'
;

DoubleVal: val=DOUBLE;
StringVal: val=STRING;
BooleanVal: val=BOOLEAN;
TupleVal: name='[' args = ExpressionList? ']';

AID: =>ID | 'PlusSelf' | 'self' | 'env' | 'it' | 'rep' | 'share' | 'nbr' | 'hood' | 'mux' | 'eval';

@Override QualifiedNameInStaticImport:
  (AID '.')+
;
terminal INT returns ecore::EInt: ('0'..'9')+;
DOUBLE returns ecore::EDouble: INT('.'INT)?('e'|'E''-'?INT)?;
BOOLEAN returns ecore::EBoolean: "true" | "false";

